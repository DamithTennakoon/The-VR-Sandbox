using System.Collections;
using System.Collections.Generic;
using UnityEngine;


/* Purpose: Control the state of the drone based on input from controller data
 * from the VR controller.
*/
public class DronePhysics : MonoBehaviour
{
    // Define GameObject objects to store the propellers
    [SerializeField] private GameObject FrontRight;
    [SerializeField] private GameObject FrontLeft;
    [SerializeField] private GameObject BackRight;
    [SerializeField] private GameObject BackLeft;

    // Define RigidBody object to store drone's rigid body property
    [SerializeField] private Rigidbody DroneRigidBody;

    // Define Transform object to store transform of drone
    [SerializeField] private Transform DroneTransform;

    // Define Floats object to store the distance between drone and propellors
    [SerializeField] private float DistFrontRight;
    [SerializeField] private float DistFrontLeft;
    [SerializeField] private float DistBackRight;
    [SerializeField] private float DistBackLeft;

    // Implement proportional controlller for Roll axis
    private float p_gain_pitch;
    private float p_gain_roll;
    private float p_gain_yaw;

    // Sensor data objects
    public float PitchError;
    public float RollError;
    public float YawError;

    // Create a object from ControllerData class
    public ControllerData InputData;



    void Start()
    {
        // Initialize sensor data;
        PitchError = 0.0f;
        RollError = 0.0f;
        YawError = 0.0f;

        // Initialize proportional gains
        p_gain_pitch = 10f;
        p_gain_roll = 2f;
        p_gain_yaw = 6f;


        // Initialize distances between propes and centre of drone mass
        DistFrontRight = Vector3.Distance(FrontRight.transform.position, DroneTransform.position);
        DistFrontLeft = Vector3.Distance(FrontLeft.transform.position, DroneTransform.position);
        DistBackRight = Vector3.Distance(BackRight.transform.position, DroneTransform.position);
        DistBackLeft = Vector3.Distance(BackLeft.transform.position, DroneTransform.position);
    }

    // Update is called once per frame
    void Update()
    {
        // Sensor data computation
        InputData.TriggerButtonValue = 0.5f;
        PitchError = ComputePitchError(DroneTransform, PitchError);
        RollError = ComputeRollErorr(DroneTransform, RollError);
        YawError = ComputeYawError(DroneTransform);

        // Add force to each propellor
        Forces(InputData.TriggerButtonValue, FrontRight, FrontLeft, BackRight, BackLeft, p_gain_pitch, p_gain_roll, p_gain_yaw, PitchError, RollError, YawError);
    }

    // TO-DO: Function: add force to rigid body
    private void Forces(float TriggerValue, GameObject FR_Prop, GameObject FL_Prop, GameObject BR_Prop, GameObject BL_Prop, float p_gain_pitch, float p_gain_roll, float p_gain_yaw,float PitchError, float RollError, float YawError)
    {
        // Temporary: float object to save force value
        float Force = 12f * TriggerValue;

        // Compute Pitch stabilization forces using propotional controller terms
        float FR_Force = Force + ((PitchError) * p_gain_pitch) - ((RollError) * p_gain_roll) - ((YawError) * p_gain_yaw);
        float FL_Force = Force + ((PitchError) * p_gain_pitch) + ((RollError) * p_gain_roll) + ((YawError) * p_gain_yaw);
        float BR_Force = Force - ((PitchError) * p_gain_pitch) - ((RollError) * p_gain_roll) + ((YawError) * p_gain_yaw);
        float BL_Force = Force - ((PitchError) * p_gain_pitch) + ((RollError) * p_gain_roll) - ((YawError) * p_gain_yaw);

        // Compute Roll stabilization forces using proportional conntroller terms

        // Add force to propellor object
        DroneRigidBody.AddForceAtPosition(transform.up * FR_Force, FR_Prop.transform.position);
        DroneRigidBody.AddForceAtPosition(transform.up * FL_Force, FL_Prop.transform.position);
        DroneRigidBody.AddForceAtPosition(transform.up * BR_Force, BR_Prop.transform.position);
        DroneRigidBody.AddForceAtPosition(transform.up * BL_Force, BL_Prop.transform.position);

        // Compute the torque generated by each motor
        float FR_Torque = FR_Force * DistFrontRight * Mathf.Sin(90) * -1;
        float FL_Torque = FL_Force * DistFrontLeft * Mathf.Sin(90);
        float BR_Torque = BR_Force * DistBackRight * Mathf.Sin(90);
        float BL_Torque = BL_Force * DistBackLeft * Mathf.Sin(90) * -1;

        // Add torque to drone rigid body
        DroneRigidBody.AddTorque(transform.up * FR_Torque);
        DroneRigidBody.AddTorque(transform.up * FL_Torque);
        DroneRigidBody.AddTorque(transform.up * BR_Torque);
        DroneRigidBody.AddTorque(transform.up * BL_Torque);

    }

    // Function: Return the pitch angle of the drone
    private float ComputePitchError(Transform DroneTransform, float PitchError)
    {
        // Caculate the current rotation of the transform
        PitchError = -1*DroneTransform.rotation.x;

        return PitchError;
    }

    // Function: Return the roll angle of the drone
    private float ComputeRollErorr(Transform DroneTransform, float RollError)
    {
        // Calculate the current rotation of the transform
        RollError = -1*DroneTransform.rotation.z;

        return RollError;
    }

    // Function: Return the yaw angle of the drone
    private float ComputeYawError(Transform DroneTransform)
    {
        // Calculate the current rotation of the transform
        float YawError = -1 * DroneTransform.rotation.y;

        return YawError;
    }
}
